# 정렬된 배열(Sorted Array)

정렬된 배열은 **ADT(추상 자료형)**인 '정렬 리스트(Sorted List)'를 배열 기반으로 구현한 자료구조다. 다음 두 가지 특성이 연산에 큰 영향을 미친다. <br>
데이터 정렬 상태 유지: 모든 요소가 특정 순서(오름차순 또는 내림차순)로 정렬되어 있다. <br>
데이터 선형 구조: 메모리에 연속적으로 저장되어 인덱스를 통해 직접 접근이 가능하다. <br>

---

### 1. 삽입(Insertion): O(N)

정렬된 배열에 데이터를 삽입할 때는 일반 배열처럼 임의의 위치에 넣지 않고, 정렬 상태를 유지하는 특정 위치에 삽입된다.<br>
따라서 삽입 이전에 새 데이터가 들어갈 위치를 찾는 과정이 필요하다.

삽입 연산은 크게 세 단계로 이루어진다:

1) 삽입할 위치 찾기 : 검색 연산으로 데이터의 삽입 위치를 특정한다 -> O(N), 이후 해당 연산을 F라고 부르겠다.
2) 데이터 이동 및 실제 삽입 : 찾은 위치에 새 데이터를 넣기 위해, 해당 위치부터 뒤의 모든 요소들을 한 칸씩 뒤로 밀어내야 한다. -> O(N - F)
3) 데이터 삽입 : 데이터를 삽입한다 -> O(1)

데이터가 삽입될 인덱스에 따라 위치를 찾는 동작(F)과 삽입을 위해 데이터를 이동시키는 동작(M)이 반비례 관계를 가진다.<br>
따라서, F + M = N이 항상 성립하므로, 삽입 연산의 동작 단계는 **O(N + 1)**이다.

---

### 2. 검색(Search): O(N)

검색 연산에 선형 탐색을 사용하는 경우, 일반 배열과 동일한 $O(N)$의 시간 복잡도를 가진다. <br>
하지만 정렬된 배열은 그 특성에서 오는 효율이 있다. <br>

자료 구조 내부에 해당 값이 존재하지 않을 경우 보다 빠르게 작업을 종료할 수 있다는 점이다. <br>
데이터가 정렬되지 않은 상태라면, 값의 존재 여부를 판단하기 위해 모든 요소를 끝까지 순회해야 한다.

반면 정렬된 배열의 경우, 찾으려는 값보다 큰 요소를 만나게 됐을 때 검색 연산을 즉시 종료할 수 있다. <br>
([1, 12, 33, 44]에서 22를 찾는 경우, 33에서 검색 연산을 종료하게 된다.)

---

### 3. 이진 탐색(Binary Search): O(logN)

이진 탐색에 대한 자세한 설명은 Algorithm에서 대신하겠다. <br>
해당 문서에서 필요한 내용은 해당 알고리즘이 선형 탐색과는 다르게 검색 연산을 $O(log N)$ 으로 만들 수 있다는 점이다.

이는 검색 연산을 보다 효율적으로 처리할 수 있음을 의미한다. <br>
하지만, 삽입 연산의 경우 삽입할 위치를 찾는 연산이 $O(log N)$으로 최적화되더라도 데이터의 이동이 $O(N)$이므로 시간복잡도는 그대로이다.

---
