# 정렬된 배열(Sorted Array)

정렬된 배열은 **ADT(추상 자료형)**인 '정렬 리스트(Sorted List)'를 배열 기반으로 구현한 자료구조다. 다음 두 가지 특성이 연산에 큰 영향을 미친다. <br>
데이터 정렬 상태 유지: 모든 요소가 특정 순서(오름차순 또는 내림차순)로 정렬되어 있다. <br>
데이터 선형 구조: 메모리에 연속적으로 저장되어 인덱스를 통해 직접 접근이 가능하다. <br>

---

### 1. 삽입(Insertion): O(N)

정렬된 배열에 데이터를 삽입할 때는 일반 배열처럼 임의의 위치에 넣지 않고, 정렬 상태를 유지하는 특정 위치에 삽입된다.<br>
따라서 삽입 이전에 새 데이터가 들어갈 위치를 찾는 과정이 필요하다.

삽입 연산은 크게 세 단계로 이루어진다:

1) 삽입할 위치 찾기 : 검색 연산으로 데이터의 삽입 위치를 특정한다 -> O(N)
2) 데이터 이동 및 실제 삽입 : 찾은 위치에 새 데이터를 넣기 위해, 해당 위치부터 뒤의 모든 요소들을 한 칸씩 뒤로 밀어내야 한다. -> O(N)
3) 데이터 삽입 : 데이터를 삽입한다 -> O(1)

이때, 정렬된 배열의 삽입 연산의 1) 과 2) 단계는 반비례한다는 독특한 관계를 가지게 된다. <br>
Big-O 표기법은 무한대로 증가하는 입력값 N에 의한 동작 횟수의 영향을 측정하는 것이므로 의미가 조금 다르지만, <br>
위 과정에서 1)의 횟수를 S, 2)의 횟수를 M이라고 가정했을 때 S + M ≈ N 이 성립한다.

---

### 2. 검색(Search): O(N)

검색 연산에 선형 탐색을 사용하는 경우, 일반 배열과 동일한 $O(N)$의 시간 복잡도를 가진다. <br>
하지만 정렬된 배열은 그 특성에서 오는 효율이 있다. <br>

자료 구조 내부에 해당 값이 존재하지 않을 경우 보다 빠르게 작업을 종료할 수 있다는 점이다. <br>
데이터가 정렬되지 않은 상태라면, 값의 존재 여부를 판단하기 위해 모든 요소를 끝까지 순회해야 한다.

반면 정렬된 배열의 경우, 찾으려는 값보다 큰 요소를 만나게 됐을 때 검색 연산을 즉시 종료할 수 있다. <br>
([1, 12, 33, 44]에서 22를 찾는 경우, 33에서 검색 연산을 종료하게 된다.)

---

### 3. 이진 검색(Binary Search): O(logN)

이진 탐색에 대한 자세한 설명은 Algorithm에서 대신하겠다. <br>
해당 문서에서 필요한 내용은 해당 알고리즘이 선형 탐색과는 다르게 검색 연산을 $O(log N)$ 으로 만들 수 있다는 점이다.

이는 검색 연산을 보다 효율적으로 처리할 수 있음을 의미한다. <br>
하지만, 삽입 연산의 경우 삽입할 위치를 찾는 연산이 $O(log N)$으로 최적화되더라도 데이터의 이동이 $O(N)$이므로 시간복잡도는 그대로이다.

---

### 4. 선형 검색 vs 이진 검색

정렬된 배열의 삽입 과정에서 어떤 검색 방법을 사용하냐에 따라 생겨나는 특수한 점이 있다. <br>
해당 과정은 데이터 삽입 이전에 저장될 메모리를 마련하기 위해 데이터를 이동시키는 과정이 있으므로, 항상 O(N)의 시간 복잡도를 가진다.

신기한 점은 선형 검색을 사용했을 때 삽입 연산과는 다르게 이진 검색의 삽입 연산 단계는 수학적 상호 관계가 성립되지 않는 점이다. <br>
위에서 언급했듯이 위치 검색(S)과 데이터 이동(M)이 존재할 때, 이진 검색은 S의 증감이 M에 영향을 끼치지 않는다.
(이진 검색의 방식이 데이터를 선형적으로 탐색하지 않기 때문에 위치(W)를 기준으로 이동될 데이터의 개수와 관계가 존재하지 않는다.)
