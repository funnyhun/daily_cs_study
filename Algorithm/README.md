# 알고리즘 (Algorithm)

이 디렉토리는 '누구나 자료 구조와 알고리즘' 서적의 알고리즘 파트 학습 내용을 정리하는 공간입니다. <br>
해당 서적은 각 장을 명확하게 분리된 내용으로 구성하기보다, 큰 개념을 이해하기 위해 작은 개념을 순차적으로 학습하도록 계획되어 있습니다. <br>
따라서 이 디렉토리 내의 각 학습 내용은 명확하게 구분되지 않고 일부 개념들이 포함되어 나타날 수 있습니다. <br>

**이 저장소에 작성된 모든 문서는 해당 서적의 내용을 토대로 개인의 생각을 자유롭게 작성한 것입니다.**

---

### 1. 알고리즘이란?

알고리즘은 특정 문제(혹은 요구사항)을 해결하기 위한 명확하고 유한한 일련의 절차이다. <br>
구체적으로, 입력(Input)이 문제 해결을 위한 동작 단계(Step)를 거쳐서 원하는 출력(Out)을 만들어내는 과정을 의미한다. <br>
이전에 자료구조 챕터에서 학습한 배열과 정렬된 배열의 검색 연산을 비교해보자.

* 선형 검색 (Linear Search): 해당 데이터를 찾을 때까지 모든 데이터를 탐색한다 -> O(N) <br>
* 이때, 알고리즘은 입력으로 주어지는 모든 데이터를 순회하는 동작을 갖는다.

* 이진 검색 (Binary Search): 해당 데이터를 찾기 위해 요소의 중간에서부터 좌 혹은 우로 방향을 설정해 요소의 범위를 절반씩 줄인다. -> O(log N) <br>
* 이때, 알고리즘은 값 비교를 통해 요소의 범위를 절반씩 줄이는 동작을 갖는다.

이처럼 동일한 검색 연산임에도 불구하고, 문제 상황(입력, 환경, 언어적 제한)을 토대로 어떤 알고리즘을 사용하냐에 따라 프로그램의 성능에 큰 영향을 끼칠 수 있다. <br>
따라서 프로그램을 구현하는 과정에서 입력 값을 토대로 로직의 효율을 고민하는 과정이 필요하고, 이때 쉽게 적용 가능한 답안지를 알고리즘이라고 생각하면 쉽다.

---

### 2. 시간복잡도란?

시간복잡도는 알고리즘을 평가하는 척도이다. <br>
이는 입력(Input)이 원하는 출력(Out)을 만들기 위한 과정(step)에 얼마나 영향을 끼치는지를 의미한다. <br>
이때, 중요한 점은 입력에 의해 단순히 늘어나는 과정이 아니라 입력과 과정 간의 관계를 설명할 수 있어야 한다는 것이다. <br>

그렇다면 시간 복잡도가 실제 실행 시간이 아닌 동작의 단계로 알고리즘의 복잡도를 평가하는 이유는 무엇일까? <br>
답은 동일한 로직이더라도 실행되는 환경에 의해서 실제 실행 시간이 달라질 수 있기 때문이다. -> 런타입 환경의 차이 <br>

즉, 시간 복잡도는 다양한 런타임 환경에서 동작하는 알고리즘의 효율성을 비교하기 위해 외부 요인(언어, 하드웨어, 운영체제 등등..)을 배제하고 <br>
로직에 명확하게 주어지는 입력값을 토대로 동작 단계의 점근적 관계의 상한을 구해 알고리즘의 효율성을 비교하는 방식이다.

추가로, 알고리즘의 평가는 일반적으로 빅오(Big-O)표기법을 사용한다. <br>
이는 빅오표기법이 알고리즘이 실행하는 시나리오 중 최악을 가정하기 때문이다. -> 프로그램의 문제는 최악의 상황에서 발생한다. <br>
만약, 최악의 입력값이 아닌 곳에서 문제가 발생한다면 이는 알고리즘의 효율성 문제가 아닌 해결하는 방법의 본질을 고민해봐야 한다.

---

### 3. 빅오표기법이란?

우리는 어떤 문제를 해결하기 위해 정해둔 일련의 과정을 "알고리즘"이라고 표현했다. <br>
이때, 알고리즘의 효율성을 비교하기 위해서는 시간복잡도라는 개념과 이를 표현하는 표기법들에 대해 알아야한다. <br>
그 중, 알고리즘 비교 과정에서 일반적으로 사용되는 빅오(Big-O)표기법에 대해서 알아보자.

빅오(Big-O)표기법의 본질은 알고리즘이 동작하는 시나리오 중 최악의 상황을 가정하여 상한을 표현하는 것이다. <br>
이는 같은 알고리즘일지라도 주어지는 시나리오(입력)에 따라 다른 동작 단계를 갖는다는 것을 의미한다. <br>
빅오표기법이 최악을 가정하는 이유는 효율성을 통해 알고리즘을 채택하는 과정에서 "비관적인" 접근이 유효하기 때문이다.

선형 탐색이라는 실제 예시를 통해서 "비관적인" 접근의 유효성에 대해서 느껴보자. <br>
선형 알고리즘의 시간복잡도는 O(N)이다. (물론, 빅오표기법으로..) <br>
하지만, 자료구조 챕터에서 선형 자료구조에 대해 학습했다면 최선의 경우 O(1)이 될 수 있다는 걸 알고 있을 것이다. <br>

이처럼, 선형 탐색은 찾으려는 데이터가 선형 자료의 어디에 위치하냐에 따라서 실제 동작 단계가 달라질 수 있다. <br>
하지만 실행 단계 이전에 예측할 수 없는 이런 기준들은 알고리즘의 효율성을 비교하기에는 어렵다. <br>

따라서 빅오표기법은 "비관적인" 접근을 통해 최악의 상황을 기준으로 삼는다. <br>
이는 어떤 입력값이 주어지더라도 동작단계가 최악의 상한선을 넘을 수 없기 떄문이다. <br>

결과적으로, 빅오표기법은 알고리즘 간의 객관적인 비교를 가능하게 만든다.

---

### 4. 동일한 시간복잡도 간의 효율성 비교

우리는 위에서 빅오에 기반한 시간 복잡도를 토대로 알고리즘의 효율성을 비교하는 것에 대해서 학습했다. <br>
이때 빅오표기법을 통한 시간 복잡도의 비교는 서로 다른 카테고리의 알고리즘일 때 효율적이다 <br>

책에서는 이를 건물에 비유하는데 각각의 카테고리는 1층 건물, 빌라, 아파트와 같이 우리가 비교하지 않아도 큰 격차를 가지고 있기 때문이다. <br>
이는 동일한 카테고리 내의 알고리즘을 비교할 때는 해당 시간 복잡도가 아닌 별도의 절차가 필요함을 의미한다. <br>
그렇다면, 어떤 절차를 통해 알고리즘을 비교해야 할까?

이에 대해 우리는 시간 복잡도에서 차수와 계수에 영향을 끼치는 실제 루프 과정에서 일어나는 기본 연산들의 횟수를 센다. <br>
구체적으로, 짝수를 출력하는 함수 A와 함수 B가 존재한다고 가정해보자. <br>

```
function A(n) {
	for (let i = 2; i <= n; i++)
		if (i % 2 == 0)
			console.log(i);
}

function B(n) {
	for (let i = 2; i <= n; i += 2)
		console.log(i);
}
```

여기서 함수 A는 N - 1번의 루프 속에서 (루프) 번의 비교연산과 (루프) / 2번의 출력 연산을 실행하게 될 것이고 <br>
함수 B는 N / 2번의 루프 속에서 (루프) 번의 출력 연산을 실행하게 된다.<br>
하지만 두 함수 모두 빅오 표기법에 의하면 상수를 제거함으로써 O(N)이다. <br>

이처럼, 동일한 카테고리에 속한 알고리즘의 경우 매 루프 안에서 발생하는 여러 단계를 계산함으로써 실제 효율성을 비교하게 된다.
+ 위 예제에서 동작 단계의 설명이 많이 축약되었으나, 핵심은 func A와 func B는 동일한 시간복잡도지만 루프 횟수 및 내부에서 다른 동작 횟수를 가진다.

---