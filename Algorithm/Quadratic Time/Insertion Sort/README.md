# 삽입 정렬(Insertion Sort)

삽입 정렬은 정렬되지 않은 정수 배열을 입력으로 받았을 때, 비교와 이동 연산을 통해 일정 범위를 순차적으로 정렬시키는 알고리즘이다. <br>

초기 i = 1에서 시작하여 0 <= range < i 의 범위까지 대상이 되는 값과 비교하며 이동 연산을 실행한다 <br>
이때, 비교되는 값이 대상 값보다 더 큰 경우 우측으로 이동시킨다 <br>
루프는 1) 대상 값보다 더 작은 값을 만나거나 2) 배열의 시작점에 도달하여 종료된다. <br>
대상 값은 루프의 종료 시점에 삽입 된다. (대상보다 더 작은 값이 있거나 대상이 제일 작은 경우)

매 루프에서 범위 내의 값들은 정렬되고 새롭게 대상이 되는 값은 해당 범위에서 올바른 자리에 삽입된다.

최악의 시나리오를 토대로,

- 1회차 : 1번
- 2회차 : 2번
- ...
- N회차 : N - 1번 (N번째 값을 기준으로 좌측과 비교하므로)

비교 연산 횟수 : 1 + 2 + ... + N - 1 이며, 이동 연산은 동일하다. <br>
이외에도 대상 값을 저장하고 삽입하는 연산이 존재하나 빅오표기법에 의해 생략된다. <br>
결과적으로, 삽입 정렬의 시간 복잡도는 O(N^2)이다.

이차 시간 알고리즘에서 버블 정렬과 선택 정렬과는 다르게 최선의 경우 O(N)이다.

---

### 1. 이동 연산을 생략하는 법에 대해서

해당 내용은 삽입 정렬을 구현하는 과정에서 어떤 자료구조를 선택하느냐에 따라 생겨나는 성능의 차이에 대해 다룬다 <br>
삽입 정렬의 주요 연산은 '비교', '이동', '삽입'으로 이루어져 있다. <br>
이때, 삽입 정렬의 핵심 내용은 정렬된 범위에 삽입 될 대상값이 삽입될 자리를 마련하는데 있다. <br>

만약, 데이터가 연속적으로 저장되지 않아서 요소 사이에 특정 요소를 바로 삽입할 수 있다면 어떨까? <br>
예시로 배열과 링크드 리스트로 삽입 정렬을 구현했을 때를 비교해보자.

배열의 경우, 데이터가 메모리에 연속적으로 존재하기 때문에 특정 요소 사이에 요소를 삽입하기 위해서는 이동 연산이 반드시 필요하다. <br>
하지만 링크드 리스트의 경우 불연속적 메모리에 존재하는 데이터를 일종의 연결고리로 관계를 유지하고 있기 때문에 요소 사이에 새로운 요소를 삽입할 수 있다.

결과적으로, 링크드 리스트로 구현한 삽입 정렬은 기존에 요구되는 이동 단계를 생략할 수 잇다.
아쉽게도 비교 단계의 시간복잡도는 그대로이기 때문에 삽입정렬의 시간복잡도는 여전히 O(N^2)이다.

---

### 2. 그럼에도 불구하고, 배열이다

위에서 우리는 삽입 정렬을 구현하는 과정에서 배열이 아닌 링크드 리스트를 사용하는 것에 대해 이야기했다. <br>
연결 리스트 혹은 이중 연결 리스트를 사용하는 경우, 우리는 삽입 정렬의 이동 단계를 생략할 수 있었다.

하지만 이동 단계를 생략하기 위해 선형 자료구조 vs 비 선형 자료구조를 선택하는 것은 알고리즘을 비교하기 위해 시간 복잡도를 비교하는 것과는 다른 문제를 가져온다. <br>
바로, 각 자료구조의 특성에서 발생하는 메모리 접근 비용의 차이이다.

선형 자료구조의 경우, 연속된 메모리에 데이터를 저장하는 특성을 토대로 "참조 지역성(Locality of Reference)"을 활용한 메모리 캐싱이 가능하다. <br>
이는 우리가 RAM에서 특정 데이터를 읽을 때, 다음에 접근할 것이라 예상되는 데이터들이 캐시 메모리에 올라가는것을 의미한다. <br>
반대로, 비 선형 자료구조는 특성 상 다음 요소의 메모리를 예측할 수 없기 때문에 메모리 캐싱이 불가하고 이는 캐시 미스를 유발한다.
[참고] CPU는 RAM에 접근하기 전에 캐시 메모리에 해당 데이터가 캐싱됐는지 확인한다. -> 캐시 히트 vs 캐시 미스

시간복잡도의 기준이 되는 기본 연산은 현대 컴퓨팅에서 굉장히 적은 비용으로 일어나기 때문에 동작 단계의 복잡성을 비교하는 것이 합리적이지만, <br>
이론과 현실에는 차이가 존재하듯이 특정 연산의 횟수를 줄이기 위해 다른 특성의 자료 구조를 선택하는 것은 기본 연산의 비용자체에 영향을 끼칠 수 있다.

---